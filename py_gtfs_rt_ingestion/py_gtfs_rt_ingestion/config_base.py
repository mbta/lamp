# use annotations to type hint a method with the type of the enclosing class
# https://stackoverflow.com/a/33533514
from __future__ import annotations

from abc import ABC
from abc import abstractmethod
from typing import Optional

from enum import auto
from enum import Enum

import pyarrow

from .error import ConfigTypeFromFilenameException


class ConfigType(Enum):
    """
    ConfigType is an Enumuration that is inclusive of all
    configuration types to be processed by this library

    """

    RT_ALERTS = auto()
    RT_TRIP_UPDATES = auto()
    RT_VEHICLE_POSITIONS = auto()
    BUS_TRIP_UPDATES = auto()
    BUS_VEHICLE_POSITIONS = auto()
    VEHICLE_COUNT = auto()

    def __str__(self) -> str:
        return self.name

    @classmethod
    def from_filename(cls, filename: str) -> ConfigType:
        """
        Figure out which config type to use for a given filename. Raise a
        ConfigTypeFromFilenameException if unable to determine.
        """
        if "mbta.com_realtime_Alerts_enhanced" in filename:
            return cls.RT_ALERTS
        if "mbta.com_realtime_TripUpdates_enhanced" in filename:
            return cls.RT_TRIP_UPDATES
        if "mbta.com_realtime_VehiclePositions_enhanced" in filename:
            return cls.RT_VEHICLE_POSITIONS
        if "com_prod_TripUpdates_enhanced" in filename:
            return cls.BUS_TRIP_UPDATES
        if "com_prod_VehiclePositions_enhanced" in filename:
            return cls.BUS_VEHICLE_POSITIONS
        if "net_vehicleCount" in filename:
            return cls.VEHICLE_COUNT

        raise ConfigTypeFromFilenameException(filename)


class ConfigDetail(ABC):
    """
    Abstract Base Class for all ConfigDetail implementations.

    ConfigDetail classes must implement all methods and properties that are
    defined.
    """

    @property
    @abstractmethod
    def config_type(self) -> ConfigType:
        """Get the config type for this config"""

    @property
    @abstractmethod
    def export_schema(self) -> pyarrow.schema:
        """Get the schema for the parquet table generated by this config"""

    @property
    @abstractmethod
    def transformation_schema(self) -> dict:
        """
        Get the transformation schema that describes how what json keys to copy
        and how to remap them if necessary
        """

    def record_from_entity(self, entity: dict) -> dict:
        """
        Convert an entity in the ingested json dict into a record for a parquet
        table.
        """

        def drill_entity(drill_keys: str) -> Optional[dict]:
            """Util function for recursively getting data out of entity"""
            ret_dict = entity
            for key in drill_keys.split(",")[1:]:
                value = ret_dict.get(key)
                if value is None:
                    return value
                ret_dict = value
            return ret_dict

        record: dict = {}
        for drill_keys, fields in self.transformation_schema.items():
            pull_dict = drill_entity(drill_keys)
            for get_field in fields:
                if pull_dict is None:
                    record[get_field[-1]] = None
                else:
                    record[get_field[-1]] = pull_dict.get(get_field[0])

        return record
