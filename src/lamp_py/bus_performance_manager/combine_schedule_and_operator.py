import random
from datetime import datetime
from typing import Tuple
import dataframely as dy
import polars as pl
from lamp_py.bus_performance_manager.events_joined import BusEvents, BusEventsOperatorJoined
from lamp_py.runtime_utils.process_logger import ProcessLogger


class TMDailyWorkPiece(dy.Schema):
    "Daily Work Piece record from TM."
    service_date = dy.Date(nullable=False)
    tm_block_id = dy.String(nullable=True)
    tm_run_id = dy.String(nullable=True)
    tm_trip_id = dy.String(nullable=True)
    operator_badge_number = dy.String(nullable=True)
    tm_vehicle_label = dy.String(nullable=True)
    logon_time = dy.Datetime(nullable=True, time_zone=None)  # figure out what timezone this should be...
    logoff_time = dy.Datetime(nullable=True, time_zone=None)


class TMDailyWorkPieceOperatorMap(TMDailyWorkPiece):  # pylint: disable=too-many-ancestors
    "Additional public bus operator ID"
    public_operator_id = dy.Int64(nullable=True)


def combine_schedule_and_run_id_operator_id(
    bus_metrics: dy.DataFrame[BusEvents], daily_work: pl.DataFrame
) -> Tuple[dy.DataFrame[BusEventsOperatorJoined], dy.DataFrame[TMDailyWorkPieceOperatorMap]]:
    """
    write_me
    """
    process_logger = ProcessLogger("combine_schedule_and_run_id_operator_id")
    process_logger.log_start()
    # create a daily unique mapping between operator badge and a randomized public identifier to tie together runs/trips and operators
    public_operator_id_map = create_public_operator_id_map(daily_work)

    # join the mapping back with the daily_work dataframe to associate the public identifier with an operator
    daily_with_public_operator_id = daily_work.join(
        public_operator_id_map, on=["operator_badge_number", "service_date"], how="left"
    )

    # join all on trip_id and vehicle to add run_id and public_operator_id for every trip
    output_bus_metrics = bus_metrics.join(
        daily_with_public_operator_id.select("tm_run_id", "tm_trip_id", "tm_vehicle_label", "public_operator_id"),
        left_on=["trip_id", "vehicle_label"],
        right_on=["tm_trip_id", "tm_vehicle_label"],
        how="left",
    ).rename({"tm_run_id": "run_id"})

    valid_operator_mapping = process_logger.log_dataframely_filter_results(
        *TMDailyWorkPieceOperatorMap.filter(daily_with_public_operator_id)
    )
    valid_bus_metrics = process_logger.log_dataframely_filter_results(
        *BusEventsOperatorJoined.filter(output_bus_metrics)
    )

    process_logger.log_complete()

    return valid_bus_metrics, valid_operator_mapping


def create_public_operator_id_map(daily_work: pl.DataFrame) -> pl.DataFrame:
    """
    Identifiers generated are unstable and depend on the timestamp during which they were generated. These are
    used to tie together the internal operator badge number with the public facing public_operator_id via the
    mapping generated by this method
    """
    random.seed(datetime.now().timestamp())

    # assign a new operator_id for each trip_id in a day. as trip ids are recycled across days,
    # prepend with date to make it unique
    operator_id_mapping = (
        daily_work.select("tm_trip_id", "operator_badge_number", "service_date")
        .with_columns(
            pl.Series(random.sample(range(10000, 99999), daily_work["tm_trip_id"].len()))
            .cast(pl.String)
            .alias("public_operator_id")
        )
        .with_columns(
            pl.concat_str([pl.col("service_date").dt.to_string(format="%Y%m%d"), pl.col("public_operator_id")])
            .cast(pl.Int64)
            .alias("public_operator_id")
        )
        .drop_nulls()
    )
    return operator_id_mapping
